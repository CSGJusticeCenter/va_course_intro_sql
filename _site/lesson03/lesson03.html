<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Lesson 3: Aggregating Data</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../libs/clipboard/clipboard.min.js"></script>
<script src="../libs/quarto-html/quarto.js" type="module"></script>
<script src="../libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../libs/quarto-html/popper.min.js"></script>
<script src="../libs/quarto-html/tippy.umd.min.js"></script>
<script src="../libs/quarto-html/anchor.min.js"></script>
<link href="../libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../libs/bootstrap/bootstrap.min.js"></script>
<link href="../libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../libs/bootstrap/bootstrap-8de619bbd21ce238746bc3d87e490689.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<link href="../libs/quarto-contrib/interactive-sql-1.0.0/interactive-sql.css" rel="stylesheet">
<link rel="preconnect" href="https://fonts.googleapis.com">

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">

<link href="https://fonts.googleapis.com/css2?family=Public+Sans:ital,wght@0,100..900;1,100..900&amp;display=swap" rel="stylesheet">
<script src="https://unpkg.com/@antonz/sqlite@3.40.0/dist/sqlite3.js"></script>
<script src="https://unpkg.com/sqlime@0.1.3/dist/sqlime-db.js"></script>
<script src="https://unpkg.com/sqlime@0.1.3/dist/sqlime-examples.js"></script>


</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#using-as-to-create-aliases" id="toc-using-as-to-create-aliases" class="nav-link" data-scroll-target="#using-as-to-create-aliases">Using <code>AS</code> to create aliases</a></li>
  <li><a href="#aggregate-functions" id="toc-aggregate-functions" class="nav-link" data-scroll-target="#aggregate-functions">Aggregate functions</a>
  <ul class="collapse">
  <li><a href="#counting-residents" id="toc-counting-residents" class="nav-link" data-scroll-target="#counting-residents">Counting residents</a></li>
  <li><a href="#calculating-average-sentence-length" id="toc-calculating-average-sentence-length" class="nav-link" data-scroll-target="#calculating-average-sentence-length">Calculating average sentence length</a></li>
  </ul></li>
  <li><a href="#using-group-by-to-organize-data" id="toc-using-group-by-to-organize-data" class="nav-link" data-scroll-target="#using-group-by-to-organize-data">Using <code>GROUP BY</code> to organize data</a>
  <ul class="collapse">
  <li><a href="#counting-residents-by-facility" id="toc-counting-residents-by-facility" class="nav-link" data-scroll-target="#counting-residents-by-facility">Counting residents by facility</a></li>
  <li><a href="#average-sentence-length-by-county" id="toc-average-sentence-length-by-county" class="nav-link" data-scroll-target="#average-sentence-length-by-county">Average sentence length by county</a></li>
  </ul></li>
  <li><a href="#filtering-grouped-with-having" id="toc-filtering-grouped-with-having" class="nav-link" data-scroll-target="#filtering-grouped-with-having">Filtering grouped with <code>HAVING</code></a>
  <ul class="collapse">
  <li><a href="#finding-facilities-with-more-than-100-residents" id="toc-finding-facilities-with-more-than-100-residents" class="nav-link" data-scroll-target="#finding-facilities-with-more-than-100-residents">Finding facilities with more than 100 residents</a></li>
  <li><a href="#counties-with-high-average-sentences" id="toc-counties-with-high-average-sentences" class="nav-link" data-scroll-target="#counties-with-high-average-sentences">Counties with high average sentences</a></li>
  </ul></li>
  <li><a href="#combining-aggregation-with-filtering" id="toc-combining-aggregation-with-filtering" class="nav-link" data-scroll-target="#combining-aggregation-with-filtering">Combining aggregation with filtering</a>
  <ul class="collapse">
  <li><a href="#average-sentence-for-recent-admissions" id="toc-average-sentence-for-recent-admissions" class="nav-link" data-scroll-target="#average-sentence-for-recent-admissions">Average sentence for recent admissions</a></li>
  </ul></li>
  <li><a href="#sorting-aggregated-results" id="toc-sorting-aggregated-results" class="nav-link" data-scroll-target="#sorting-aggregated-results">Sorting aggregated results</a>
  <ul class="collapse">
  <li><a href="#intake-count-by-county" id="toc-intake-count-by-county" class="nav-link" data-scroll-target="#intake-count-by-county">Intake count by county</a></li>
  </ul></li>
  <li><a href="#key-takeaways" id="toc-key-takeaways" class="nav-link" data-scroll-target="#key-takeaways">Key takeaways</a></li>
  <li><a href="#additional-resources" id="toc-additional-resources" class="nav-link" data-scroll-target="#additional-resources">Additional resources</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Lesson 3: Aggregating Data</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>Now that you’ve learned how to filter and sort records using <code>WHERE</code> and <code>ORDER BY</code>, it’s time to go a level deeper by learning how to <strong>summarize and group data</strong>. As a corrections analyst, you’ll often be asked to answer high-level questions that go beyond individual records—like how many residents were admitted last month, how many are currently housed in each facility, or what the average sentence length is by intake type. To answer these types of questions, you’ll need to understand how to use <strong>aggregate functions</strong> and <strong>grouping</strong> in SQL.</p>
<p>Aggregate functions allow you to summarize values across multiple rows, and grouping helps you organize data into meaningful categories—such as by facility, intake date, or sentencing county.</p>
<p>This lesson covers the following:</p>
<ul>
<li><p>Using <code>AS</code> to create column <strong>aliases</strong> that make your query results easier to read</p></li>
<li><p>Using aggregate functions like <code>COUNT()</code>, <code>SUM()</code>, <code>AVG()</code>, <code>MIN()</code>, and <code>MAX()</code> to generate summary statistics</p></li>
<li><p>Using <code>GROUP BY</code> to group records and apply aggregates by category</p></li>
<li><p>Filtering grouped data with <code>HAVING</code> to narrow your analysis</p></li>
<li><p>Combining aggregation with filtering and sorting</p></li>
</ul>
<p>These techniques are essential for building dashboards, generating monthly reports, and presenting digestible metrics to supervisors or stakeholders.</p>
</section>
<section id="using-as-to-create-aliases" class="level2">
<h2 class="anchored" data-anchor-id="using-as-to-create-aliases">Using <code>AS</code> to create aliases</h2>
<p>Before we dive into aggregating data, let’s cover a small but important tool that makes your queries easier to read: the <code>AS</code> keyword.</p>
<p>In SQL, you can use the <code>AS</code> keyword to create <strong>aliases</strong>, or temporary names, for columns and even entire tables. Aliases make your query results more readable—especially when you’re working with calculated values or columns with unclear names.</p>
<p>For example, if you write a query that calculates the average sentence length, the default column label will appear as something like <code>avg(sentence_years)</code>, which may not be very user friendly. By using <code>AS</code>, you can rename that output column to something more meaningful, like <code>average_sentence_years</code>.</p>
<p>Here’s a basic example:</p>
<div class="interactive-sql">
<div class="sourceCode" id="cb1"><pre class="sourceCode sql interactive state_doc code-with-copy"><code class="sourceCode sql"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="fu">AVG</span>(sentence_years) <span class="kw">AS</span> average_sentence_years</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> intakes;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now, instead of seeing a default column name like <code>avg(sentence_years)</code>, the result will display a column called <code>average_sentence_years</code>, which is much clearer and easier to understand in a report or dashboard.</p>
<p>Aliases are especially helpful under the following circumstances:</p>
<ul>
<li><p>Formatting outputs for export or presentation where you want the output column to have a meaningful label</p></li>
<li><p>Preparing a report that will be shared with non-technical stakeholders</p></li>
<li><p>Preparing data for visualizations in tools like Tableau or Power BI</p></li>
<li><p>Writing queries with calculated fields or nested functions</p></li>
</ul>
<p>You can also use <code>AS</code> with table names in more complex queries (e.g., when working with joins), which we’ll cover in a later lesson.</p>
</section>
<section id="aggregate-functions" class="level2">
<h2 class="anchored" data-anchor-id="aggregate-functions">Aggregate functions</h2>
<p>Aggregate functions are powerful tools that allow you to perform calculations across multiple rows of data and return a single, summarized value. These functions are essential when you want to answer questions about totals, averages, counts, minimums, maximums, and more.</p>
<p>In corrections work, aggregate functions help analysts transform raw data into insights that inform system improvements, monitor trends, and evaluate system performance. Instead of analyzing each individual case or resident, you can look at group-level patterns and generate summary statistics that tell a broader story.</p>
<p><strong>Common aggregate functions:</strong></p>
<ul>
<li><p><code>COUNT()</code>: Counts the number of rows that match a condition</p></li>
<li><p><code>SUM()</code>: Adds together all values in a given column</p></li>
<li><p><code>AVG()</code>: Calculates the average value</p></li>
<li><p><code>MIN()</code>: Finds the smallest value</p></li>
<li><p><code>MAX()</code>: Finds the largest value</p></li>
</ul>
<p>Each of these functions helps answer critical questions. For example:</p>
<ul>
<li><p><code>COUNT()</code> can tell you how many residents are admitted at any given time.</p></li>
<li><p><code>AVG()</code> can help determine the average sentence length or age at first arrest.</p></li>
<li><p><code>MAX()</code> might help identify the most recent release-ready date.</p></li>
<li><p><code>MIN()</code> could show the earliest date of admission still pending processing.</p></li>
<li><p><code>SUM()</code> can total up sentence years by county or facility to assess case distribution.</p></li>
</ul>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Data Quality Assurance
</div>
</div>
<div class="callout-body-container callout-body">
<p>While aggregate functions like COUNT() can quickly tell you how many records meet certain criteria, keep in mind that these numbers are only as accurate as the underlying data. In real-world corrections datasets, you might encounter issues like records that haven’t been updated to reflect escapes, releases, or data entry errors. Always consider whether there are factors that could impact the quality or completeness of the data before drawing conclusions.</p>
<p>Want to learn more about spotting and addressing data issues? Check out our Data Quality course for practical strategies and real-world examples.</p>
</div>
</div>
<p>Let’s walk through a few examples that simulate the kinds of questions corrections analysts might encounter in their day-to-day work.</p>
<section id="counting-residents" class="level3">
<h3 class="anchored" data-anchor-id="counting-residents">Counting residents</h3>
<p>Imagine your supervisor asks for a report with the total number of residents currently in the system. You can use the <code>COUNT()</code> function as follows:</p>
<div class="interactive-sql">
<div class="sourceCode" id="cb2"><pre class="sourceCode sql interactive state_doc code-with-copy"><code class="sourceCode sql"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> <span class="fu">COUNT</span>(resident_id) <span class="kw">AS</span> total_residents </span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> residents;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>What this query does:</strong></p>
<p>This query counts every row in the <code>residents</code> table and gives the result an alias (<code>total_residents</code>) using the <code>AS</code> keyword. It’s a quick way to assess the size of the population you’re working with.</p>
</section>
<section id="calculating-average-sentence-length" class="level3">
<h3 class="anchored" data-anchor-id="calculating-average-sentence-length">Calculating average sentence length</h3>
<p>Now suppose your supervisor is reviewing sentencing trends and wants to know the average sentence length (in years) for residents in your system. You could use:</p>
<div class="interactive-sql">
<div class="sourceCode" id="cb3"><pre class="sourceCode sql interactive state_doc code-with-copy"><code class="sourceCode sql"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span>  <span class="fu">AVG</span>(sentence_years) <span class="kw">AS</span> avg_sentence_length</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> intakes;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>What this query does:</strong></p>
<p>This query calculates the average number of sentence years across all intake records.</p>
<p>These types of calculations are not only useful for internal reporting, but they also support external transparency, performance measurement, and strategic decision-making.</p>
</section>
</section>
<section id="using-group-by-to-organize-data" class="level2">
<h2 class="anchored" data-anchor-id="using-group-by-to-organize-data">Using <code>GROUP BY</code> to organize data</h2>
<p>While aggregate functions are useful for summarizing entire datasets, they become even more powerful when used with the <code>GROUP BY</code> clause. <code>GROUP BY</code> allows you to group rows that share the same value in one or more columns and then apply aggregate functions to each group.</p>
<p>In corrections data, this is especially useful when you want to analyze trends or metrics across specific categories, such as facilities, counties, offense groups, or intake years. Instead of looking at totals or averages across the entire dataset, you can break the data down into meaningful segments.</p>
<p>For example, you might want to do the following:</p>
<ul>
<li><p>Count the number of residents per facility to monitor population levels.</p></li>
<li><p>Calculate the average sentence length for residents admitted from each county.</p></li>
<li><p>Find the number of intakes per month to observe seasonal patterns in admissions.</p></li>
</ul>
<p>These types of grouped summaries help corrections analysts identify resource needs, flag irregularities, and better understand the variation across locations or time periods.</p>
<p>The <code>GROUP BY</code> clause is written <strong>after</strong> the <code>WHERE</code> clause and <strong>before</strong> the <code>ORDER BY</code> clause, if used. When using <code>GROUP BY</code>, each column in your <code>SELECT</code> statement must either be an aggregate function or be included in the <code>GROUP BY</code> clause.</p>
<p>Let’s put it into practice!</p>
<section id="counting-residents-by-facility" class="level3">
<h3 class="anchored" data-anchor-id="counting-residents-by-facility">Counting residents by facility</h3>
<p>You’ve been asked to generate a snapshot of how many residents are currently housed at each facility to help administrators track population levels across the system. The following can be used to query the resident count per facility:</p>
<div class="interactive-sql">
<div class="sourceCode" id="cb4"><pre class="sourceCode sql interactive state_doc code-with-copy"><code class="sourceCode sql"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> facil_id, <span class="fu">COUNT</span>(<span class="op">*</span>) <span class="kw">AS</span> total_residents</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> intakes</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">GROUP</span> <span class="kw">BY</span> facil_id;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>What this query does:</strong></p>
<p>This query groups all intake records by <code>facil_id</code> and counts how many records (residents) are in each group. The result shows the total number of residents per facility.</p>
<p><em>In a corrections setting, this could help identify overcrowded facilities or support planning for transfers and resource allocation.</em></p>
</section>
<section id="average-sentence-length-by-county" class="level3">
<h3 class="anchored" data-anchor-id="average-sentence-length-by-county">Average sentence length by county</h3>
<p>Your department is reviewing sentencing trends by region, and you’ve been asked to report the average sentence length of residents admitted from each county. Use this query to find the average sentence lengths by county:</p>
<div class="interactive-sql">
<div class="sourceCode" id="cb5"><pre class="sourceCode sql interactive state_doc code-with-copy"><code class="sourceCode sql"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> county_id, <span class="fu">AVG</span>(sentence_years) <span class="kw">AS</span> avg_sentence_years</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> intakes</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">GROUP</span> <span class="kw">BY</span> county_id;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>What this query does:</strong></p>
<p>This query groups intake records by county_id and calculates the average number of sentence years for each group.</p>
<p><em>This kind of insight could help analysts detect sentencing disparities across counties or monitor the effectiveness of recent system improvements.</em></p>
<p>These examples show just a few ways that grouping data enhances analytical insights. By breaking down large tables into meaningful subgroups, corrections analysts can go beyond individual-level records and begin to see patterns, trends, and opportunities for improvement in the system.</p>
</section>
</section>
<section id="filtering-grouped-with-having" class="level2">
<h2 class="anchored" data-anchor-id="filtering-grouped-with-having">Filtering grouped with <code>HAVING</code></h2>
<p>Once you’ve grouped your data using <code>GROUP BY</code>, you might want to filter the grouped results. That’s where the <code>HAVING</code> clause comes in. While the <code>WHERE</code> clause filters rows <strong>before</strong> grouping, <code>HAVING</code> filters <strong>after</strong> the data has been grouped. This distinction is important—<code>WHERE</code> limits which rows are included in the groups, and <code>HAVING</code> limits which <strong>groups</strong> appear in the results.</p>
<p><strong>Why this matters in corrections</strong></p>
<p>As a corrections analyst, you’ll often need to report on summary data—but not every group is always relevant. For instance, you might want to know which facilities have more than 100 residents or which counties have an average sentence length above a certain threshold. <code>HAVING</code> helps you narrow your focus to those specific groups that meet criteria <strong>after</strong> aggregation.</p>
<p>Let’s look at a few realistic scenarios to get some hands-on practice using <code>HAVING</code> in corrections-focused queries.</p>
<section id="finding-facilities-with-more-than-100-residents" class="level3">
<h3 class="anchored" data-anchor-id="finding-facilities-with-more-than-100-residents">Finding facilities with more than 100 residents</h3>
<p>Department leadership is reviewing capacity across all facilities and wants you to identify only those facilities that house more than 100 residents. You would first group the data by facility and then filter those results using <code>HAVING</code>:</p>
<div class="interactive-sql">
<div class="sourceCode" id="cb6"><pre class="sourceCode sql interactive state_doc code-with-copy"><code class="sourceCode sql"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> facil_id, <span class="fu">COUNT</span>(<span class="op">*</span>) <span class="kw">AS</span> total_residents</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> intakes</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">GROUP</span> <span class="kw">BY</span> facil_id</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">HAVING</span> <span class="fu">COUNT</span>(<span class="op">*</span>) <span class="op">&gt;</span> <span class="dv">100</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>What this query does:</strong></p>
<p>This query returns only those facilities where the resident count exceeds 100.</p>
<p><em>This kind of query could help prioritize where to focus efforts for population management or support resource allocation in overcrowded facilities.</em></p>
</section>
<section id="counties-with-high-average-sentences" class="level3">
<h3 class="anchored" data-anchor-id="counties-with-high-average-sentences">Counties with high average sentences</h3>
<p>Suppose your supervisor asks for a list of counties where the average sentence length is over 10 years. You could use the following query:</p>
<div class="interactive-sql">
<div class="sourceCode" id="cb7"><pre class="sourceCode sql interactive state_doc code-with-copy"><code class="sourceCode sql"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> county_id, <span class="fu">AVG</span>(sentence_years) <span class="kw">AS</span> avg_sentence_years</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> intakes</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">GROUP</span> <span class="kw">BY</span> county_id</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="kw">HAVING</span> <span class="fu">AVG</span>(sentence_years) <span class="op">&gt;</span> <span class="dv">10</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>What this query does:</strong></p>
<p>This filters the grouped county data to show only those counties with an average sentence exceeding 10 years.</p>
<p><em>This is useful for system reviews or identifying jurisdictions where sentencing practices may need further investigation.</em></p>
<p>The <code>HAVING</code> clause gives you precision when working with aggregated data, allowing you to answer complex questions and produce focused, actionable insights.</p>
</section>
</section>
<section id="combining-aggregation-with-filtering" class="level2">
<h2 class="anchored" data-anchor-id="combining-aggregation-with-filtering">Combining aggregation with filtering</h2>
<p>In real-world data analysis, it’s common to combine aggregation functions with filtering criteria to narrow your focus before calculating summary statistics. This helps ensure your results are relevant to a specific timeframe, subgroup, or operational question.</p>
<p>For example, suppose you want to evaluate average sentence lengths, but only for residents admitted after a particular date. You can use a <code>WHERE</code> clause to apply the filter before grouping the data and calculating the average. Let’s look at a practical example.</p>
<section id="average-sentence-for-recent-admissions" class="level3">
<h3 class="anchored" data-anchor-id="average-sentence-for-recent-admissions">Average sentence for recent admissions</h3>
<p>Decision-makers would like to review sentencing trends starting in 2022. You’re asked to compile a report of the average sentence length for residents admitted on or after January 1, 2022, by county:</p>
<div class="interactive-sql">
<div class="sourceCode" id="cb8"><pre class="sourceCode sql interactive state_doc code-with-copy"><code class="sourceCode sql"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> county_id, <span class="fu">AVG</span>(sentence_years) <span class="kw">AS</span> avg_sentence</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> intakes</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">WHERE</span> admission_date <span class="op">&gt;=</span> <span class="st">'2022-01-01'</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="kw">GROUP</span> <span class="kw">BY</span> county_id;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>What this query does:</strong></p>
<p>This query filters the <code>intakes</code> table to include only residents admitted after January 1, 2022. It then groups the data by <code>county_id</code> and calculates the average number of sentence years for each county.</p>
<p><em>This type of query is valuable for identifying trends in sentencing across different counties over a recent timeframe.</em></p>
</section>
</section>
<section id="sorting-aggregated-results" class="level2">
<h2 class="anchored" data-anchor-id="sorting-aggregated-results">Sorting aggregated results</h2>
<p>Once you’ve grouped and summarized your data, you may want to sort the results to make them easier to interpret. This is where the ORDER BY clause comes in; it helps you rank or organize your aggregated data based on the values returned by functions like <code>COUNT()</code>, <code>AVG()</code>, or <code>SUM()</code>.</p>
<p>Sorting aggregated results allows you to identify patterns or outliers more quickly. For example, you might want to know which counties have the highest number of intakes, or which facilities have the longest average sentence length.</p>
<section id="intake-count-by-county" class="level3">
<h3 class="anchored" data-anchor-id="intake-count-by-county">Intake count by county</h3>
<p>You are tasked with analyzing the number of intakes by county for the past month. Leadership wants to know which counties have the highest number of residents entering the system so they can allocate additional resources where needed. You can sort the results as follows to identify which counties have the most intakes:</p>
<div class="interactive-sql">
<div class="sourceCode" id="cb9"><pre class="sourceCode sql interactive state_doc code-with-copy"><code class="sourceCode sql"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">SELECT</span> county_id, <span class="fu">COUNT</span>(<span class="op">*</span>) <span class="kw">AS</span> intake_count</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> intakes</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">GROUP</span> <span class="kw">BY</span> county_id</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="kw">ORDER</span> <span class="kw">BY</span> intake_count <span class="kw">DESC</span>;</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>What this query does:</strong></p>
<p>This query groups the data by county_id and counts how many intake records exist for each one. It then sorts the results in descending order, so the counties with the highest number of intakes appear first.</p>
<p><em>By sorting this way, corrections analysts can quickly see which counties are sending the most people into the system. This information can guide decisions about staffing, resource allocation, or the need for further investigation into high-volume regions. It may also help inform collaboration or support efforts with local jurisdictions.</em></p>
</section>
</section>
<section id="key-takeaways" class="level2">
<h2 class="anchored" data-anchor-id="key-takeaways">Key takeaways</h2>
<ul>
<li><p>Adding <strong>aliases</strong> with <code>AS</code> makes your results cleaner and easier to read, especially when displaying calculations or summaries in dashboards or reports.</p></li>
<li><p><strong>Aggregate functions</strong> allow you to summarize data across multiple rows. These are useful for generating high-level insights from large datasets, such as tracking total intakes or calculating average sentence lengths.</p></li>
<li><p>The <code>GROUP BY</code> clause is used when you want to perform aggregation for each unique value in a column—like getting a count of residents per facility or average sentence per county.</p></li>
<li><p>When using <code>GROUP BY</code>, each column in your <code>SELECT</code> statement must either be an aggregate function or be included in the <code>GROUP BY</code> clause.</p></li>
<li><p><strong>Filtering grouped data</strong> with <code>HAVING</code> allows you to refine your results <strong>after</strong> the aggregation step. This is different from the <code>WHERE</code> clause, which filters rows <strong>before</strong> aggregation.</p></li>
<li><p>You can use <code>ORDER BY</code> with aggregated data to sort your results—either alphabetically, numerically, or chronologically.</p></li>
</ul>
<p>By knowing how to group, aggregate, and organize your results, you can extract meaningful trends from corrections data. These skills are essential for analysts who need to monitor population levels; identify outliers; or report on patterns across facilities, counties, or time periods.</p>
<hr>
<p>In this lesson, you learned how to summarize and group data using SQL aggregate functions and the <code>GROUP BY</code> clause—essential skills for generating high-level insights from large corrections datasets. In the next lesson, you’ll build on these concepts by learning how to join multiple tables, allowing you to pull in additional context and create more comprehensive queries across your database.</p>
</section>
<section id="additional-resources" class="level2">
<h2 class="anchored" data-anchor-id="additional-resources">Additional resources</h2>
<ul>
<li>W3Schools.com (Website with more in-depth SQL learning and practice)</li>
<li>MySQL Cookbook, Fourth Edition</li>
</ul>
<sqlime-db name="state_doc" path="https://raw.githubusercontent.com/CSGJusticeCenter/va_data/main/courses/intro_sql/state_doc.db"></sqlime-db>
<sqlime-examples db="state_doc" selector="div.interactive-sql pre.state_doc code" editable=""></sqlime-examples>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
            // target, if specified
            link.setAttribute("target", "_blank");
            if (link.getAttribute("rel") === null) {
              link.setAttribute("rel", "noopener");
            }
            // default icon
            link.classList.add("external");
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




<script src="../libs/quarto-contrib/interactive-sql-1.0.0/interactive-sql.js"></script>
</body></html>